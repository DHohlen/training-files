Mit einem regulären Ausdruck, kurz RegEx, sucht man ein bestimmtes Muster innerhalb einer Zeichenkette, das in der Regel mehrmals gefunden werden kann. Zum Beispiel kann der reguläre Ausdruck abc in den Zeichenketten abc123, 123abc und 123abcxyz gefunden werden. Der reguläre Ausdruck kann um einen Anker ergänzt werden, wenn das Suchmuster nur am Anfang oder Ende einer Zeichenkette gefunden werden soll.

Character classes: Eine character class (dt.: Zeichenklasse) definiert einen Satz von Zeichen, von denen jedes in einer Eingabezeichenfolge enthalten sein kann, damit eine Übereinstimmung vorliegt. Dies kann über selbstdefinierte Zeichenklassen erfolgen ([abc] sucht jedes Zeichen, das entweder ein a,b oder c ist), oder über eine vordefinierte Zeichenklassen (\d steht für digit und sucht eine Ziffer, entspräche also [0-9]

Anchors: Anchor geben eine Position in der Zeichenfolge an, an der eine Übereinstimmung auftreten muss. Die Engine durchsucht für reguläre Ausdrücke nicht die Zeichenfolge oder durchläuft Zeichen, sondern sucht nur an der angegebenen Position nach einer Übereinstimmung. Beispielsweise gibt ^ an, dass die Übereinstimmung am Anfang einer Zeile oder Zeichenfolge beginnen muss. Daher stimmt der reguläre Ausdruck ^http: nur mit "http:" überein, wenn dies am Anfang einer Zeile steht.

Escaped characters: Die meisten Zeichen wie abc123 können direkt in einem regulären Ausdruck verwendet werden. Wenn man aber eines der Sonderzeichen "$ ^ { [ ( | ) * + ? \" suchen muss, ist es notwendig, einen umgekehrten Schrägstrich (Backslash "\") davor zu setzen. So entspricht z.B. \n einer neuen Zeile

Groups & Lookarounds: Gruppierungskonstrukte grenzen die Teilausdrücke eines regulären Ausdrucks ab und zeichnen die Teilzeichenfolgen einer Eingabezeichenfolge auf. Ein Beispiel ist das folgende Gruppierungskonstrukt, das einen übereinstimmenden Teilausdruck erfasst: "( Teilausdruck )" wobei Teilausdruck ein beliebiges gültiges Muster eines regulären Ausdrucks ist.
Perl Version 5 führte zusätzlich zu den üblichen regulären Ausdrücken auch look-ahead und look-behind assertions (etwa „vorausschauende“ bzw. „nach hinten schauende“ Annahmen oder Behauptungen) ein, was unter dem Begriff look-around assertions zusammengefasst wird.[7] Diese Konstrukte erweitern die regulären Ausdrücke um die Möglichkeit, kontextabhängige (engl.: „context sensitive“) Bedingungen zu formulieren, ohne den Kontext selbst als passend zu finden. Das heißt, möchte man alle Zeichenfolgen „Sport“ finden, denen die Zeichenfolge „verein“ folgt, ohne dass jedoch die gefundene Zeichenfolge die Zeichenfolge „verein“ selbst enthält, wäre dies mit einer look-ahead assertion möglich: Sport(?=verein). Im Beispielsatz „Ein Sportler betreibt Sport im Sportverein.“ würde jener reguläre Ausdruck also zum letzten Vorkommen von „Sport“ passen, da nur diesem die Zeichenfolge „verein“ folgt; er würde jedoch nicht zur Teilzeichenkette „Sportverein“ passen.

Quantifiers & Alternation: Quantifizierer geben an, wie viele Instanzen eines Zeichens, einer Gruppe oder einer Zeichenklasse in der Eingabe vorhanden sein müssen, damit eine Übereinstimmung gefunden wird. So gibt "*" an, ob es eine Übereinstimmung mit null oder mehr Vorkommen gibt.
Alternierungskonstrukte ändern einen regulären Ausdruck, um Entweder-Oder-Vergleiche oder eine bedingte Übereinstimmung zuzulassen. So kann man das vertikale Balkenzeichen (|) für Vergleiche mit einem oder mehreren aus einer Reihe von Mustern verwenden, wobei das |-Zeichen als Trennzeichen für die einzelnen Muster dient.