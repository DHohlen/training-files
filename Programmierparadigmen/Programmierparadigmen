Decorator-Pattern:
Dieses Pattern ist eine flexible Alternative zur Unterklassenbildung, um zusätzliche Funktionalitäten zu erweitern, besonders wenn die Zahl der Unterklassen sehr groß werden würde. Eines der Probleme dieses Patterns ist jedoch die Erstellung vieler kleiner Objekte, die sich zudem noch oft stark ähneln. Die Objekte unterscheiden sich primär dadurch, wie sie untereinander vernetzt sind, nicht durch ihre Klasse oder den Wert ihrer Variablen. Auch wenn diese System einfach anpassbar sind durch diejenigen, die sie verstehen, können sie hart zu lernen und debuggen sein.

Factory-Pattern:
Das Factory Pattern fällt in die Klasse der creational Patterns. Das Muster beschreibt, wie ein Objekt durch Aufruf einer Methode anstatt durch direkten Aufruf eines Konstruktors erzeugt wird.

Gateway-Pattern:
An API gateway is a service which is the single entry-point for API requests into an application from outside the firewall.

Interfaces vs Abstrakte Klassen:
Interfaces sind zwar wie abstrakte Klassen vollständig als abstract deklariert (wenn auch implizit), jedoch enthalten Interfaces ausschließlich abstrakte Methoden und Konstanten. Alle Methoden eines Interface sind implizit abstract, und alle Datenelemente sind implizit final static. Abstrakte Klassen dagegen können sowohl variable Datenelemente als auch nicht abstrakte, implementierte Methoden besitzen.

Observer-Pattern:
Das Observer-Pattern definiert eine one-to-many dependency zwischen Objekten, so dass wenn ein Objekt(Subjekt) seinen Zustand ändert, all seine verbunden Objekte (Beobachter) automatisch informiert und automatisch geupdated werden. Dabei kann ein Subjekt beliebig viele Beobachter haben. 

Dependency-Injection:
Dependency Injection ist ein Entwurfsmuster, das die Abhängigkeiten eines Objekts zur Laufzeit reglementiert: Benötigt ein Objekt beispielsweise bei seiner Initialisierung ein anderes Objekt, ist diese Abhängigkeit an einem zentralen Ort hinterlegt – es wird also nicht vom initialisierten Objekt selbst erzeugt.

Repositories:
Das Repository Pattern entspricht der Auftrennung zwischen Businesslogik und der Datenbeschaffung, unabhängig der Datenquelle. Häufig wird in der Businesslogik auf Datenquellen zugegriffen, um diverse Daten zu laden, diese in Objekte zu mappen und um diese anschließend anzuzeigen und/oder zu manipulieren. Nun stelle man sich eine größere Anwendung vor. Quer durch sämtliche Businesslogik wird nun auf Daten zugegriffen um diese zu manipulieren. Ein Repository ist eine zentrale Stelle, die sich darum kümmert, den Zugriff zu Entität XY zu gewähren (woher auch immer) und eine Anlage/Änderung in einem korrekten Zustand weiter zu leiten. Die Businesslogik selbst verwendet das jeweilige Repository um auf die Daten zuzugreifen mit dem Vorteil, dass alle relevanten Stellen denselben Code durchlaufen. Dieser muss dementsprechend nur an einer einzigen Stelle gewartet werden. Selbst Änderungen an der Datenbeschaffung selbst bleibt der Businesslogik verborgen, da nur für das Repository relevant.
